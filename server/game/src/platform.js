// Generated by LiveScript 1.2.0
(function(){
  var ref$, each, map, filter, lines, keys, values, abs, signum, join, Platform;
  ref$ = require('prelude-ls'), each = ref$.each, map = ref$.map, filter = ref$.filter, lines = ref$.lines, keys = ref$.keys, values = ref$.values, abs = ref$.abs, signum = ref$.signum, join = ref$.join;
  Phaser.Group.prototype.each = function(func){
    return (function(first, next){
      var results$ = [];
      if (!first) {
        return;
      }
      func(first);
      while ((next = this.next()) !== first) {
        results$.push(func(next));
      }
      return results$;
    }.call(this, this.cursor, this.cursor));
  };
  this.Platform = Platform = (function(superclass){
    var prototype = extend$((import$(Platform, superclass).displayName = 'Platform', Platform), superclass).prototype, constructor = Platform;
    Platform.create = {
      black: function(game, x, y, width, height){
        return new Platform(game, x, y, width, height, 'black');
      },
      white: function(game, x, y, width, height){
        return new Platform(game, x, y, width, height, 'white');
      }
    };
    function Platform(game, x, y, width, height, color){
      Platform.superclass.call(this, game);
      this.color = color;
      this.enableBody = true;
      this.physicsBodyType = Phaser.Physics.ARCADE;
      this.x = x;
      this.y = y;
      (function(w, h, scale){
        var x$, y$, z$, z1$;
        this.inside = scale(this.create(0, 0, color), w, h);
        x$ = this.top = scale(this.create(0, -2, 'empty'), w, 1);
        x$.part = 'top';
        x$.relativeDimension = 'width';
        x$.body.checkCollision.up = false;
        x$.body.checkCollision.left = false;
        x$.body.checkCollision.right = false;
        y$ = this.bottom = scale(this.create(0, h + 1, 'empty'), w, 1);
        y$.part = 'bottom';
        y$.relativeDimension = 'width';
        y$.body.checkCollision.down = false;
        y$.body.checkCollision.left = false;
        y$.body.checkCollision.right = false;
        z$ = this.left = scale(this.create(-2, 0, 'empty'), 1, h);
        z$.part = 'left';
        z$.relativeDimension = 'height';
        z$.body.checkCollision.left = false;
        z$.body.checkCollision.up = false;
        z$.body.checkCollision.down = false;
        z1$ = this.right = scale(this.create(w + 1, 0, 'empty'), 1, h);
        z1$.part = 'right';
        z1$.relativeDimension = 'height';
        z1$.body.checkCollision.right = false;
        z1$.body.checkCollision.up = false;
        z1$.body.checkCollision.down = false;
        this.edges = [this.top, this.bottom, this.left, this.right];
        this.each(function(it){
          return it.body.immovable = true;
        });
        this.body = this.inside.body;
      }.call(this, width || 1, height || 1, function(object, width, height){
        var x$, y$;
        x$ = object;
        y$ = x$.scale;
        y$.x = width;
        y$.y = height;
        return x$;
      }));
    }
    prototype.update = function(){
      var this$ = this;
      each(function(it){
        return it.body.velocity = this$.inside.body.velocity;
      })(
      this.edges);
    };
    prototype.debug = function(game){
      this.each(bind$(game.debug, 'body'));
    };
    return Platform;
  }(Phaser.Group));
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
