// Generated by LiveScript 1.2.0
(function(){
  var ref$, each, any, all, fold, foldr, filter, reject, map, empty, keys, values, abs, signum, join, x$, bodyBounds, unionify, unionExcluding, unionBelow, area, dimensionFrom, dimensionBetween;
  ref$ = require('prelude-ls'), each = ref$.each, any = ref$.any, all = ref$.all, fold = ref$.fold, foldr = ref$.foldr, filter = ref$.filter, reject = ref$.reject, map = ref$.map, empty = ref$.empty, keys = ref$.keys, values = ref$.values, abs = ref$.abs, signum = ref$.signum, join = ref$.join;
  x$ = Phaser.Physics.Arcade.Body.prototype;
  x$.bounds = function(){
    return new Phaser.Rectangle(this.x, this.y, this.width, this.height);
  };
  bodyBounds = function(sprite){
    var b;
    b = sprite.body;
    return new Phaser.Rectangle(b.x, b.y, b.width, b.height);
  };
  unionify = function(func){
    return func(function(total, overlap){
      if (Phaser.Rectangle.intersects(overlap, total)) {
        return Phaser.Rectangle.union(overlap, total);
      } else {
        return total;
      }
    });
  };
  unionExcluding = function(platform, player){
    var overlaps, rect;
    overlaps = map(function(it){
      return it.intersection;
    })(
    reject(function(it){
      return it.platform === platform;
    })(
    player.overlapping));
    if (empty(overlaps)) {
      return new Phaser.Rectangle(0, 0, 0, 0);
    }
    rect = unionify(fold)(overlaps.pop(), overlaps);
    return unionify(foldr)(rect, overlaps);
  };
  unionBelow = function(platform, player){
    var overlaps, rect;
    overlaps = map(function(it){
      return it.intersection;
    })(
    reject(function(it){
      return it.platform.layer < platform.layer;
    })(
    player.overlapping));
    if (empty(overlaps)) {
      return new Phaser.Rectangle(0, 0, 0, 0);
    }
    rect = unionify(fold)(overlaps.pop(), overlaps);
    return unionify(foldr)(rect, overlaps);
  };
  area = function(rect){
    return rect.width * rect.height;
  };
  dimensionFrom = function(body){
    switch (false) {
    case !(body.overlapX <= 0 && body.overlapY <= 0):
      return console.log("Man x is " + body.overlapX + " and y is " + body.overlapY);
    case !(body.overlapX > body.overlapY):
      return 'height';
    case !(body.overlapX <= body.overlapY):
      return 'width';
    default:
      return 'width';
    }
  };
  dimensionBetween = function(bounds1, bounds2){
    var intersect, ref$;
    intersect = Phaser.Rectangle.intersection(bounds1, bounds2);
    switch (ref$ = [intersect], false) {
    case !function(it){
      return it.width >= it.height;
    }(ref$[0]):
      return 'width';
    default:
      return 'height';
    }
  };
  this.PlatformCollision = {
    collide: curry$(function(physics, platforms, player){
      if (!physics) {
        throw "Invalid physics " + physics;
      }
      player.overlapping = [];
      each(function(platform){
        return physics.collide(player, platform.inside, null, PlatformCollision.processInsideBackdrop(player.color, platform));
      })(
      platforms);
      each(function(platform){
        return physics.collide(player, platform.inside, null, PlatformCollision.processInsideWall(player.color, platform));
      })(
      platforms);
      return each(function(platform){
        return physics.collide(player, platform.edges, null, PlatformCollision.processEdge(player.color, platform));
      })(
      platforms);
    }),
    processInsideBackdrop: function(color, platform){
      switch (false) {
      case !(!color || !platform.color):
        throw "Something went wrong with platform/player color!";
      case color !== platform.color:
        return function(){
          return false;
        };
      default:
        return function(player, platformInside){
          var intersect;
          intersect = Phaser.Rectangle.intersection;
          player.overlapping.push({
            platform: platform,
            intersection: intersect(bodyBounds(player), bodyBounds(platformInside))
          });
          return false;
        };
      }
    },
    processInsideWall: function(color, platform){
      switch (false) {
      case !(!color || !platform.color):
        throw "Something went wrong with platform/player color!";
      case color !== platform.color:
        return function(player, platformInside){
          var intersect, playerBounds, intersection, playerArea, checkRect, dimen;
          intersect = Phaser.Rectangle.intersection;
          playerBounds = bodyBounds(player);
          intersection = intersect(playerBounds, bodyBounds(platformInside));
          playerArea = area(playerBounds);
          checkRect = unionBelow(platform, player);
          if (area(intersection) > playerArea * 0.9) {
            if (area(checkRect) > playerArea * 0.9) {
              return false;
            } else {
              player.core.playerDead();
              return true;
            }
          } else {
            dimen = dimensionBetween(bodyBounds(platformInside), playerBounds);
            if (checkRect[dimen] < player.body[dimen] - 0.5) {
              return true;
            } else {
              return false;
            }
          }
        };
      default:
        return function(){
          return false;
        };
      }
    },
    processEdge: function(color, platform){
      switch (false) {
      case !(!color || !platform.color):
        throw "Something went wrong with platform/player color!";
      case color !== platform.color:
        return null;
      default:
        return function(player, platformEdge){
          var dimen, checkRect;
          dimen = platformEdge.relativeDimension;
          checkRect = unionExcluding(platform, player);
          if (checkRect[dimen] < player.body[dimen] - 2) {
            return true;
          } else {
            return !Phaser.Rectangle.intersects(bodyBounds(platformEdge), checkRect);
          }
        };
      }
    }
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
