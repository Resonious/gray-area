// Generated by LiveScript 1.2.0
(function(){
  var ref$, each, map, filter, lines, keys, values, abs, signum, join, towards, axis, calculateAxis, Player;
  ref$ = require('prelude-ls'), each = ref$.each, map = ref$.map, filter = ref$.filter, lines = ref$.lines, keys = ref$.keys, values = ref$.values, abs = ref$.abs, signum = ref$.signum, join = ref$.join;
  towards = curry$(function(current, target, amount){
    var increment, passed, result;
    switch (false) {
    case current !== target:
      break;
    default:
      increment = null;
      passed = null;
      if (current > target) {
        increment = (function(it){
          return it - amount;
        });
        passed = curry$(function(x$, y$){
          return x$ < y$;
        });
      } else {
        increment = (function(it){
          return it + amount;
        });
        passed = curry$(function(x$, y$){
          return x$ > y$;
        });
      }
      result = increment(current);
      if (passed(result, target)) {
        return target;
      } else {
        return result;
      }
    }
  });
  axis = curry$(function(l, r){
    var ref$;
    switch (ref$ = [l, r], false) {
    case !(true === ref$[0] && false === ref$[1]):
      return -1;
    case !(false === ref$[0] && true === ref$[1]):
      return 1;
    default:
      return 0;
    }
  });
  calculateAxis = function(leftB, rightB){
    if (!(leftB && rightB)) {
      return 0;
    }
    return axis(leftB.isDown, rightB.isDown);
  };
  this.Player = Player = (function(superclass){
    var prototype = extend$((import$(Player, superclass).displayName = 'Player', Player), superclass).prototype, constructor = Player;
    function Player(game, x, y, color){
      var x$, y$;
      Player.superclass.call(this, game, x, y, "player-" + color);
      this.color = color;
      game.physics.arcade.enable(this);
      this.anchor.setTo(0.5, 0.5);
      x$ = this.body;
      x$.bounce.y = 0.1;
      x$.bounce.x = 0;
      x$.gravity.y = 2000;
      x$.collideWorldBounds = true;
      x$.setSize(22, 57);
      y$ = this.animations;
      y$.add('idle', [0], 0, true);
      y$.add('walk', [0, 1, 2, 1], 13, true);
      y$.play('idle');
    }
    prototype.arrowKeys = null;
    prototype.maxSpeed = 200;
    prototype.acceleration = 50;
    prototype.deceleration = 50;
    prototype.targetDirection = 0;
    prototype.jumpTimer = 0.0;
    prototype.jumpTimeout = 0.55;
    prototype.jumpForce = 500;
    prototype.jumpBoostFactor = 0.01;
    prototype.jumpWhileOffGroundTime = 0.1;
    prototype.airTimer = 0.0;
    prototype.update = function(){
      var delta, keys, axis, jump;
      delta = this.game.time.physicsElapsed;
      keys = null;
      axis = 0;
      jump = 0;
      if (this.arrowKeys && this.arrowKeys()) {
        keys = this.arrowKeys();
        axis = calculateAxis(keys.left, keys.right);
        jump = keys.up.isDown;
      }
      if (axis !== 0) {
        this.targetDirection = axis;
      }
      this.updateAnimation(axis, delta);
      this.updateMovement(axis, jump, delta);
    };
    prototype.updateAnimation = function(axis, delta){
      var direction, target, absIs, ref$;
      direction = signum(this.body.velocity.x) || 0;
      target = this.targetDirection;
      absIs = curry$(function(x, y){
        return abs(y) === x;
      });
      switch (ref$ = [direction, axis], false) {
      case !(0 === ref$[0] && 0 === ref$[1]):
        this.animations.play('idle');
        break;
      case !(absIs(1)(ref$[0]) && (function(it){
          return it !== direction;
        })(ref$[1])):
        this.scale.x = target;
        this.animations.play('walk');
        break;
      default:
        if (target !== 0) {
          this.scale.x = target;
        }
        this.animations.play('walk');
      }
    };
    prototype.updateMovement = function(axis, jump, delta){
      var passed, towardsZeroBy;
      if (isNaN(
      this.body.velocity.x)) {
        this.body.velocity.x = 0;
      }
      if (axis !== 0) {
        passed = (function(){
          switch (this.targetDirection) {
          case 1:
            return curry$(function(x$, y$){
              return x$ > y$;
            });
          case -1:
            return curry$(function(x$, y$){
              return x$ < y$;
            });
          default:
            return function(){
              return false;
            };
          }
        }.call(this));
        if (!passed(this.body.velocity.x, this.maxSpeed * this.targetDirection)) {
          this.body.velocity.x += this.acceleration * axis;
        }
      } else {
        towardsZeroBy = towards(this.body.velocity.x, 0);
        this.body.velocity.x = towardsZeroBy(this.deceleration);
      }
      if (this.isGrounded()) {
        this.airTimer = 0;
      } else {
        this.airTimer += delta;
      }
      if (jump) {
        if (this.isGrounded() || this.airTimer < this.jumpWhileOffGroundTime) {
          this.body.velocity.y = -this.jumpForce;
          this.jumpTimer = 0.1;
        } else if (this.jumpTimer !== 0) {
          this.body.velocity.y -= this.jumpForce * this.jumpBoostFactor;
        }
      }
      if (this.jumpTimer !== 0) {
        this.jumpTimer += delta;
      }
      if (this.jumpTimer >= this.jumpTimeout) {
        this.jumpTimer = 0;
      }
    };
    prototype.isGrounded = function(){
      return this.body.blocked.down || this.body.touching.down;
    };
    return Player;
  }(Phaser.Sprite));
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
